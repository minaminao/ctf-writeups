# Writeup for Safe Prime

次の Python スクリプトとその出力が与えられます:

```python
import os
from Crypto.Util.number import getPrime, isPrime

FLAG = os.getenv("FLAG", "ctf4b{*** REDACTED ***}").encode()
m = int.from_bytes(FLAG, 'big')

while True:
    p = getPrime(512)
    q = 2 * p + 1
    if isPrime(q):
        break

n = p * q
e = 65537
c = pow(m, e, n)

print(f"{n = }")
print(f"{c = }")
```

RSA のようですが通常の RSA と異なり、 $q$ がランダムな素数ではなく $2p + 1$ となっています。

これにより $n$ の素因数分解が簡単にできそうです。

$$n = pq = p(2p + 1)$$

であり、

$$2p^2 + p - n = 0$$

となり、 $p$ を未知数とした二次方程式を解くと、 $p$ が求まり $q, d$ も求まります。

あとは通常の RSA と同様に復号すればよいです。

よって、以下のスクリプトでフラグを復元できます。

```python
from Crypto.Util.number import long_to_bytes
import math

n = 292927367433510948901751902057717800692038691293351366163009654796102787183601223853665784238601655926920628800436003079044921928983307813012149143680956641439800408783429996002829316421340550469318295239640149707659994033143360850517185860496309968947622345912323183329662031340775767654881876683235701491291

a = 2
b = 1
c = -n
p = (-b + math.isqrt(b * b - 4 * a * c)) // (2 * a)
q = 2 * p + 1
assert p * q == n

c = 40791470236110804733312817275921324892019927976655404478966109115157033048751614414177683787333122984170869148886461684367352872341935843163852393126653174874958667177632653833127408726094823976937236033974500273341920433616691535827765625224845089258529412235827313525710616060854484132337663369013424587861
e = 65537

d = pow(e, -1, (p - 1) * (q - 1))
flag = long_to_bytes(pow(c, d, n))

print(flag)
```

Flag: `ctf4b{R3l4ted_pr1m3s_4re_vuLner4ble_n0_maTt3r_h0W_l4rGe_p_1s}`
